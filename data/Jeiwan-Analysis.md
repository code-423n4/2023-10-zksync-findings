zkSync is a layer-2 protocol that's intended to scale the Ethereum blockchain using the technology of Zero-Knowledge Proofs. The architecture of the protocol can be looked at as a combination of three mechanisms:
1. A blockchain. Foremost, zkSync is a blockchain, with its own block production and validation processes. It also has its own Virtual Machine (EraVM) that seeks to achieve the equivalence with EVM as much as possible. Unlike EVM, EraVM uses ZKPs to execute transactions in a verifiable wayâ€“this is the main invention of zkSync and the main tool that lets zkSync scale the Ethereum blockchain.
2. An L1<->L2 bridge. ZkSync sets up a bridge (multiple bridges, in fact) with Ethereum to make the zkSync blockchain available to all Ethereum users. The bridges are smart contracts that allow users to transfer ETH and ERC20 between the networks, as well as execute zkSync contracts from Ethereum. In the audited codebase, there's also a new bridge contract that facilitates the bridging of the WETH token (wrapping and unwrapping when sending and receiving ETH).
3. L1 finalization. What makes layer-2 protocols different from regular blockchains is that they use a different (layer-1) blockchain for state finalization. While transactions on zkSync have instant confirmation, zkSync finalizes them on Ethereum: every batch of transactions on zkSync is reported to an Ethereum contract that checks the validity of the batch. Batches can only be executed and validated consequently, guaranteeing the in-order processing of L1->L2 transactions. An important requirement for the finalization process is the ability to reconstruct the entire state of zkSync from the finality data reported to Ethereum. Zero-knowledge proofs and EraVM make the finalization much cheaper by reducing the amount of data that needs to be reported to Ethereum: instead of reporting entire transactions, zkSync reports only the proofs of their execution, which can be cheaply verified.

As any blockchain, zkSync requires a centralized actor who processes user transactions and builds blocks. Moreover, on zkSync, such actor is also responsible for inclusion of L1->L2 transactions in L2 blocks and for reporting L2 batches to Ethereum. This role is called "operator". Currently, there's only one operator that's run by Matter Labs, the developers of zkSync, but, in the future, it's expected that operators will be distributed and decentralized. As such, the operator must not be trust, or the trust must be minimized as much as possible. In the current implementation, the operator is only trusted to provide gas prices when creating a new batch, as well as to perform other operations required for processing transactions.

The audited codebase is of high quality: it's clean and clear, well-documented, reasonably tested, and it follows the best practices and standards. The code of the bootloader, which is written in Yul, is a great example of a well-organized and clean codebase written in a low-level programming Language. The only issue that could be improved in the codebase is the usage of interfaces and constants: since the project is split into multiple sub-projects (e.g. Ethereum contracts, zkSync contracts, system contracts, etc.), some interfaces and constants are duplicated to be re-used. This requires maintaining multiple copies of one interface (e.g. `IContractDeployer`/`IL2ContractDeployer`) and ensuring that a constant has the same value in different sub-projects.

For such a well-programmed and vigorously audited project as zkSync, the main risks, in our opinion, are:
1. The centralization risks. The operator, while being a partially trusted actor, is responsible for processing very critical operations for the entire blockchain. The protocol should ensure the actions of the operator are verified and validated as much as possible, and the possible damage caused by a malicious operator should be kept as minimal as possible.
2. Upgradeability risks. It's not uncommon that a solid codebase becomes vulnerable through an upgraded contract or a new contract added to its ecosystem. All contract upgrades, including minor ones, should be audited and review in the context of the entire ecosystem.

### Time spent:
60 hours