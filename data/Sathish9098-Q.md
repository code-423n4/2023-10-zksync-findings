FALSE	Some tokens may revert when  zero value transfers are made	In spite of the fact that EIP-20 [states](https://github.com/ethereum/EIPs/blob/46b9b698815abbfa628cd1097311deee77dd45c5/EIPS/eip-20.md?plain=1#L116) that zero-valued transfers must be accepted, some tokens, such as LEND will revert if this is attempted, which may cause transactions that involve other tokens (such as batch operations) to fully revert. Consider skipping the transfer if the amount is zero, which will also save gas.	IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount); , IERC20(erc20).safeTransfer(msg.sender, _amount);	

FALSE	Allowed fees/rates should be capped by smart contracts	Fees/rates should be required to be below 100%, preferably at a much lower limit, to ensure users don't have to monitor the blockchain for changes prior to using the protocol	256      function setBigBangEthMarketDebtRate(uint256 _rate) external onlyOwner { , 257          bigBangEthDebtRate = _rate;

FALSE	Array lengths not checked	If the length of the arrays are not required to be of the same length, user operations may not be fully executed due to a mismatch in the number of items iterated over, versus the number of items provided in the second array	310           address[] calldata users, 311           uint256[] calldata maxBorrowParts,

FALSE	Draft imports may break in new minor versions	While OpenZeppelin draft contracts are safe to use and have been audited, their 'draft' status means that the EIPs they're based on are not finalized, and thus there may be breaking changes in even [minor releases](https://docs.openzeppelin.com/contracts/3.x/api/drafts). If a bug is found in this version of OpenZeppelin, and the version that you're forced to upgrade to has breaking changes in the new version, you'll encounter unnecessary delays in porting and testing replacement contracts. Ensure that you have extensive test coverage of this area so that differences can be automatically detected, and have a plan in place for how you would fully test a new version of these contracts if they do indeed change unexpectedly. Consider creating a forked version of the file rather than importing it from the package, and manually patch your fork as changes are made.	5:    import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol";																							
																										
FALSE	Functions calling contracts/addresses with transfer hooks are missing reentrancy guards	Even if the function follows the best practice of check-effects-interaction, not using a reentrancy guard when there may be transfer hooks will open the users of this protocol up to [read-only reentrancies](https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/) with no way to protect against it, except by block-listing the whole protocol.	/// @audit `extractUnderlying()` 148:             IERC20(erc20).safeTransfer(msg.sender, _amount);																							
																										
FALSE	Use Ownable2Step rather than Ownable	[Ownable2Step](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa/contracts/access/Ownable2Step.sol#L31-L56) and [Ownable2StepUpgradeable ]p (https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/access/Ownable2StepUpgradeable.sol#L47-L63 ) revent the contract ownership from mistakenly being transferred to an address that cannot handle it (e.g. due to a typo in the address), by requiring that the recipient of the owner permissions actively accept via a contract call of its own.	26    contract TapiocaWrapper is Ownable { , 22    contract Multicall3 is Ownable {																							
																										
FALSE	Signature use at deadlines should be allowed	According to [EIP-2612](https://github.com/ethereum/EIPs/blob/71dc97318013bf2ac572ab63fab530ac9ef419ca/EIPS/eip-2612.md?plain=1#L58), signatures used on exactly the deadline timestamp are supposed to be allowed. While the signature may or may not be used for the exact EIP-2612 use case (transfer approvals), for consistency's sake, all deadlines should follow this semantic. If the timestamp is an expiration rather than a deadline, consider whether it makes more sense to include the expiration timestamp as a valid timestamp, as is done for deadlines.	159:         if (participant.expiry < block.timestamp) { ,  require(aoTapOption.expiry > block.timestamp, "adb: Option expired");																							
																										
FALSE	NFT doesn't handle hard forks	When there are hard forks, users often have to go through [many hoops](https://twitter.com/elerium115/status/1558471934924431363) to ensure that they control ownership on every fork. Consider adding require(1 == chain.chainId), or the chain ID of whichever chain you prefer, to the functions below, or at least include the chain ID in the URI, so that there is no confusion about which chain is the owner of the NFT.	function tokenURI( 69           uint256 _tokenId  70       ) public view override returns (string memory) {  71           return tokenURIs[_tokenId];																							
																										
FALSE	decimals() is not a part of the ERC-20 standard	The decimals() function is not a part of the [ERC-20 standard](https://eips.ethereum.org/EIPS/eip-20), and was added later as an [optional extension](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol). As such, some valid ERC20 tokens do not support this interface, so it is unsafe to blindly cast all tokens to this interface, and then call this function.	_paymentToken.decimals() , _paymentToken.decimals()																							
																										
FALSE	tokenURI() does not follow EIP-721	The [EIP](https://eips.ethereum.org/EIPS/eip-721) states that tokenURI() "Throws if _tokenId is not a valid NFT", which the code below does not do. If the NFT has not yet been minted, tokenURI() should revert	68       function tokenURI(																							
																										
FALSE	Open TODOs	Code architecture, incentives, and error handling/reporting questions/issues should be resolved before deployment	//    (TODO: Word better?) ,// TODO: Make whole function unchecked																							
																										
FALSE	Calls to _get() will revert when totalSupply() returns zero	totalSupply() being zero will result in a division by zero, causing the transaction to fail. The function should instead special-case this scenario, and avoid reverting.	uint256 lpPrice = (SG_POOL.totalLiquidity() * 51:              uint256(UNDERLYING.latestAnswer())) / SG_POOL.totalSupply();																							
																										
FALSE	latestAnswer() is deprecated	Use latestRoundData() instead so that you can tell whether the answer is stale or not. The latestAnswer() function returns zero if it is unable to fetch data, which may be the case if ChainLink stops supporting this API. The API and its deprecation message no longer even appear on the ChainLink website, so it is dangerous to continue using it.	uint256 _btcPrice = uint256(BTC_FEED.latestAnswer()) * 1e10;

FALSE	Missing checks for ecrecover() signature malleability	ecrecover() accepts as valid, two versions of signatures, meaning an attacker can use the same signature twice, or an attacker may be able to front-run the original signer with the altered version of the signature, causing the signer's transaction to revert due to nonce reuse. Consider adding checks for signature malleability, or using OpenZeppelin's ECDSA library to perform the extra checks necessary in order to prevent malleability.	206:             if (signer == ecrecover(digest, v, r, s)) {																							
																										
FALSE	Code does not follow the best practice of check-effects-interaction	Code should follow the best-practice of [check-effects-interaction](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-11-coding-patterns/topic/checks-effects-interactions/), where state variables are updated before any external calls are made. Doing so prevents a large class of reentrancy bugs.

FALSE	addStrategyToken() does note remove old entries before adding new ones																									
																										
FALSE	name() is not a part of the ERC-20 standard																									
																										
FALSE	symbol() is not a part of the ERC-20 standard																									
																										
FALSE	SafeTransferLib does not ensure that the token contract exists																									
																										
FALSE	Tokens may be minted to address(0x0)

																																																																																																																																												